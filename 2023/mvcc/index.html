<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>深入理解 MVCC - hwy的小窝</title><meta name=description content="前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细节并不清晰，如果让我来实现一个 MVCC 无从下手。而且既然 MVCC 可以解决 Non-repeatable Read 问题，那它能不能解决其他隔离性的问题？如何做到？最近阅读到了《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》这篇论文对 MVCC 的实现有了更深入的了解，这篇文章就是我结合论文和自己的一些理解来尝试剖析一下 MVCC。
MVCC 简介 Multi-Version concurrency control(MVCC) 从名字上看就是一种并发控制算法用以控制并发读写单一对象时的行为，尽可能减少竞争并保证一定隔离性。实现的基本原理是同时维护同一个逻辑对象（Logical Object） 不同时间段的逻辑对象，而一个逻辑对象在某个时间段的数据被称为一个 Version ，当对一个对象进行读/写操作时会根据相应的规则返回特定的 Version ，如果对某个对象完成了更新操作并不会直接将更新应用在其访问的 Version 对象上，而且重新创建一个新 Version 对象。
MVCC 实现 在论文中将 MVCC 的关键组件分为四个：Protocol、Version Storage、GC（Garbage Collection）和 Index，而 MVCC 所管理的逻辑对象可以是一个事务（Transactions）或者数据表的一行数据（Tuple/Record），一般都是以 tuple 为操作对象，下面都以 tuple 来介绍。tuple 的存储格式如下（不同 protocol 会有所区别） 1. Protocol MVTO（Timestamp Ordering） MVTO 为每个事务分配一个唯一的时间戳($T_{id}$)，它会中止所有试图读/更新已经被设置 write lock 的 version tuple（当 txn-id 不等于 0 或者自己的 $T_{id}$ 时表示有其他事务持有 write lock）的事务。MVTO 协议的 tuple header 如下： 对 tuple A 进行读操作： a."><meta name=author content="Baymax_hwy"><link href=https://baymaxhwy.github.io/an-old-hope.min.css rel=stylesheet><link href=https://baymaxhwy.github.io/style.css rel=stylesheet><link rel=apple-touch-icon href=https://baymaxhwy.github.io/apple-touch-icon.png><link rel=icon href=https://baymaxhwy.github.io/favicon.ico><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/atom+xml href=https://baymaxhwy.github.io/index.xml title=hwy的小窝><script>function setTheme(){const n=new Date,a=localStorage.getItem("date"),s=String(n.getMonth()+1)+"."+String(n.getDate()),o=n.getTime();let e,t;function i(){if(o>e&&o<t)return;document.body.classList.add("dark")}s!==a?(fetch("https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215").then(e=>e.json()).then(n=>{e=n.sunrise.split(":").map(Number),t=n.sunset.split(":").map(Number)}).catch(()=>{e=[7,0],t=[19,0]}).finally(()=>{e=n.setHours(e[0],e[1],0),t=n.setHours(t[0],t[1],0),i(),localStorage.setItem("sunrise",e),localStorage.setItem("sunset",t)}),localStorage.setItem("date",s)):(e=Number(localStorage.getItem("sunrise")),t=Number(localStorage.getItem("sunset")),i())}</script></head><body class=single><script>setTheme()</script><header class=header><nav class=nav><p class=logo><a href=https://baymaxhwy.github.io/>hwy的小窝</a></p><ul class=menu><li><a href=/posts/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>深入理解 MVCC</h1><div class=post-meta>Baymax_hwy · February 13, 2023</div></header><div class=post-content><h2 id=前言>前言</h2><p>印象中第一次看见 <code>MVCC</code> 是在<a href=https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321>《DDIA》</a>这本书上，书中 <code>MVCC</code> 是作为解决 <a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads>Non-repeatable Read</a> 问题的解决方法提出的，当时觉得非常<strong>nb</strong>，但是现在细想来其实对其中的实现细节并不清晰，如果让我来实现一个 <code>MVCC</code> 无从下手。而且既然 <code>MVCC</code> 可以解决 <code>Non-repeatable Read</code> 问题，那它能不能解决其他隔离性的问题？如何做到？最近阅读到了<a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/wu-vldb2017.pdf>《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》</a>这篇论文对 <code>MVCC</code> 的实现有了更深入的了解，这篇文章就是我结合论文和自己的一些理解来尝试剖析一下 <code>MVCC</code>。</p><h2 id=mvcc-简介>MVCC 简介</h2><p><code>Multi-Version concurrency control(MVCC)</code> 从名字上看就是一种并发控制算法用以<strong>控制并发读写单一对象时的行为，尽可能减少竞争并保证一定隔离性</strong>。实现的基本原理是同时维护同一个逻辑对象（<code>Logical Object</code>） 不同时间段的逻辑对象，而一个逻辑对象在某个时间段的数据被称为一个 <code>Version</code> ，当对一个对象进行读/写操作时会根据相应的规则返回特定的 <code>Version</code> ，如果对某个对象完成了更新操作并不会直接将更新应用在其访问的 <code>Version</code> 对象上，而且重新创建一个新 <code>Version</code> 对象。</p><h2 id=mvcc-实现>MVCC 实现</h2><p>在论文中将 <code>MVCC</code> 的关键组件分为四个：<code>Protocol</code>、<code>Version Storage</code>、<code>GC（Garbage Collection）</code>和 <code>Index</code>，而 MVCC 所管理的逻辑对象可以是一个事务（<code>Transactions</code>）或者数据表的一行数据（<code>Tuple/Record</code>），一般都是以 <code>tuple</code> 为操作对象，下面都以 <code>tuple</code> 来介绍。<code>tuple</code> 的存储格式如下（不同 <code>protocol</code> 会有所区别）
<img src=../../resources/md_imgs/mvcc_tuple_format.png alt="Tuple 格式"></p><h3 id=1-protocol>1. Protocol</h3><h4 id=mvtotimestamp-ordering>MVTO（Timestamp Ordering）</h4><p><code>MVTO</code> 为每个事务分配一个唯一的时间戳($T_{id}$)，它会中止所有试图读/更新已经被设置 <code>write lock</code> 的 <code>version tuple</code>（当 <code>txn-id</code> 不等于 0 或者自己的 $T_{id}$ 时表示有其他事务持有 <code>write lock</code>）的事务。<code>MVTO</code> 协议的 <code>tuple header</code> 如下：
<img src=../../resources/md_imgs/mvcc_mvto_tuple_header.png alt></p><ol><li>对 <code>tuple A</code> 进行读操作：
a. 搜索 <code>A</code> 的所有 <code>version</code> 中满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts
b. 并且没有其他事务持有该 <code>version</code> 的 <code>write lock</code>，则可以读该 version
c. 如果 read-ts &lt; $T_{id}$ 的话，更新 read-ts = $T_{id}$</li><li>对 <code>tuple B</code> 进行更新：
a. 找到 <code>B</code> 的最新 <code>version</code>（$B_x$），并满足 b、c 条件
b. 没有其他事务持有 <code>write lock</code>
c. $T_{id}$ >= read_ts
d. 如果满足 b、c 条件则创建一个新版本的 tuple $B_{x+1}$，并加写锁 $B_x$，令其 txn-id = $T_{id}$，当事务 <code>commit</code> 时，更新 $B_{x+1}$ 的 begin-ts = $T_{id}$，end-ts = <code>INF</code></li></ol><p>思考：读/更新操作冲突的情况？</p><h4 id=mvoccoptimistic-concurrency-control>MVOCC（Optimistic Concurrency Control）</h4><p><code>MVOCC</code> 将事务分为三个阶段：<code>read phase</code>、<code>validation phase</code>、<code>write phase</code>
<img src=../../resources/md_imgs/mvcc_mvocc_tuple_header.png alt></p><ol><li>read phase：可以进行对 <code>tuple</code> 的读和更新操作
a. 读只需要找到满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts 的 <code>version</code> 就可以读
b. 更新则需要 <code>tuple</code> 最新的 <code>version</code> 没有被加写锁并且同样会和 <code>MVTO</code> 一样创建新的 $B_{x+1}$ 的新 <code>version</code>，并且设置 $B_x.txn-id = T_{id}$（这里新创建的 $B_{x+1}$ 对其他事务<strong>不可见</strong>）</li><li>validation phase：事务 <code>commit</code> 时，为事务重新分配一个时间戳 $T_{commit}$，验证该事务的所有读操作的 <code>tuple</code> 集合是否存在并发的事务在对同一个 <code>tuple</code> 进行更新操作，如果没有则通过验证，否则中止事务</li><li>write phase：将新创建的 <code>versions</code> 正式写入到存储中，并更新其 begin_ts = $T_{commit}$ end_ts = <code>INF</code></li></ol><p>思考：</p><ol><li>读/更新操作冲突的情况？</li><li><code>MVOCC</code> 和 <code>MVTO</code> 的区别？</li></ol><h4 id=mv2pltwo-phase-locking>MV2PL（Two-phase Locking）</h4><p><code>MV2PL</code> 每个事务会<strong>预先申请</strong>好其所需要读/写相关 <code>tuple</code> 的 <code>lock</code>，<code>write lock</code> 是 <code>txn-id</code>，<code>read-lock</code> 是 <code>read-cnt</code>，当事务中止或者提交时再释放所持有的锁
<img src=../../resources/md_imgs/mvcc_mv2pl_tuple_header.png alt></p><ol><li>读 <code>tuple A</code> 获取 <code>read lock</code>：
a. 搜索 <code>A</code> 的所有 <code>version</code> 中满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts
b. 没有其他事务持有该 <code>version</code> 的 <code>write lock</code>，则 <code>read-cnt + 1</code></li><li>更新 <code>tuple B</code> 获取 <code>write lock</code>：
a. 找到 <code>B</code> 最新的 <code>version</code>（$B_x$），满足以下两个条件则获得 $B_x$ 的 <code>write lock</code>
b. 没有其他事务持有 <code>write lock</code>
c. <code>read-cnt = 0</code></li><li>更新 <code>tuple B</code> 会和之前的协议一样创建新的 <code>version</code>($B_{x+1}$)</li><li>事务提交时：<code>DBMS</code> 会分配一个 $T_{commit}$ 去更新被事务新创建的 <code>version.begin-ts</code> 并且释放所有其持有的 lock（read-cnt - 1, txn-id = 0）</li></ol><p>思考：</p><ol><li>读/更新操作冲突的情况？</li><li>和之前两个协议的区别？</li><li>上面这个 <code>MV2PL</code> 有什么问题？</li></ol><h4 id=ssiserialization-snapshot-isolation>SSI（Serialization Snapshot Isolation）</h4><p><code>SSI</code> 是在其他 <code>MVCC</code> (除开 <code>MV2PL</code>) 方法的基础上实现串行化的方法，它的理论基础是为每个之间事务定义 <code>dependency</code> 关系（设存在两个并行事务 <code>T1</code>、<code>T2</code>）:
1. ww-dependency: 两个事务先后对同一个对象 <code>X</code> 进行写入操作
2. wr-dependency：<code>T1</code> 写入 <code>X</code> 后（提交之前） <code>T2</code> 读取 <code>X</code>
3. rw-dependency(也叫 anti-dependency)：<code>T1</code> 读取了 <code>X</code>，<code>T2</code> 写入了一个更新的 <code>X</code></p><p>如果当前正在运行的事务集合中存在连续的两个 <code>anti-dependecy</code> 并且 <code>dependecy</code> 成环就可能出现异常现象，<code>SSI</code> 就是追踪 <code>anti-dependency</code> 如果发现连续的就中止其中一个事务（会重试事务），具体细节可参考论文 <a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/p1850_danrkports_vldb2012.pdf title="Serializable Snapshot Isolation in PostgreSQL">《Serializable Snapshot Isolation in PostgreSQL》</a></p><p><strong>write-skew(写倾斜)</strong>
在 MVCC 中不能保证串行化的协议天然会存在 write-skew 的情况，例如：当前两个医生值班，每天需要满足至少一个医生在岗值班其他医生才能请假，这时并发两个事务分别对两个医生进行请假，他们都先读取到了一个 <code>version</code> （有两个人值班），满足条件，然后都请假成功，最终不满足值班条件。</p><p>思考：</p><ol><li><code>SSI</code> 和 <code>MV2PL</code> 的区别？</li></ol><h3 id=2-version-storage>2. Version Storage</h3><p><code>Version Storage</code> 是解决如何存储同一个 <code>tuple</code> 的多个 <code>version</code>，不同的方法之间对于读写性能的影响也不同，这里主要介绍四种方法。
<img src=../../resources/md_imgs/mvcc_version_storage.png alt></p><ol><li><strong>Append-only Storage</strong>: 每个 <code>table</code> 中的所有 <code>tuple version</code> 都存储在同一空间中，同一个 <code>tuple</code> 的不同 <code>version</code> 构成单向链表（方便实现 <code>lock-free</code>），根据链表 <code>HEAD</code> 指向的 <code>version</code> 不同可以分为：<code>O2N</code>（Oldest-to-Newest） 和 <code>N2O</code> （Newest-to-Oldest）
a. <code>O2N</code>：<code>HEAD</code> 指向最旧的 <code>version</code>，优点：新增 <code>version</code> 时不需要更新 <code>index</code>，缺点：查询最新 <code>version</code> 需要遍历链表
b. <code>N2O</code>：<code>HEAD</code> 指向最新的 <code>version</code>，优点：查询最新 <code>version</code> 很快，缺点：新增 <code>version</code> 时需要更新 <code>index</code>
<code>Append-only</code> 的缺点：<code>version</code> 冗余复制了尚未修改的数据项</li><li><strong>Time-Travel Storage</strong>：这种方法将老旧的 <code>version</code> 另外放在一个 <code>time-travel table</code> 中存储，只有最新的 <code>version</code> 存储在 <code>main</code> <code>table</code> 中，每次创建新的 <code>version</code> 就在 <code>time-travel table</code> 中创建一个新的 <code>version</code> 将 <code>main table</code> 中的 <code>version</code> 复制，然后将修改直接应用在 <code>main table</code> 的 <code>version</code> 上（<code>time-travel table</code> 中的 <code>version</code> 也是链表形式存储）
优点：不需要更新 <code>index</code>，查询最新的 <code>version</code> 很快
缺点：和 <code>Append-only</code> 一样存在冗余复制</li><li><strong>Delta Storage</strong>：和 <code>Time-Travel</code> 类似最新的 <code>version</code> 存储在 <code>main table</code> 中，其他 <code>version</code>（被称为 <code>Delta version</code>）存储在 <code>delta table</code> 中，但是仅存储被修改的数据项
优点：对于更新操作频繁的更节省空间
缺点：对于读操作需要遍历 <code>delta table</code> 链表来获取完整的 <code>tuple</code>（非最新）</li></ol><h3 id=3-gc>3. GC</h3><p><code>MVCC</code> 会无限制的创建 <code>version</code> 最终导致超出存储空间，因此需要 <code>GC</code> 来及时回收哪些无用的 <code>version</code> 所占用的存储空间。</p><blockquote><p>无用的 version：1. 属于被中止的事务；2. end-ts 小于所有正在运行事务的 $T_{id}$。</p></blockquote><p><code>GC</code> 运行可以分为三步：1. 检测出无用 <code>version</code>；2. 将 <code>version</code> 从其所属的 <code>version</code> 链表中移除并更新索引；3. 回收 <code>version</code> 存储空间</p><p>主要的设计难点在于如何快速有效的检测出无用 <code>version</code> 减少 <code>GC</code> 运行时间</p><p><strong>Epoch-Based memory management</strong>：是一种粗力度的追踪 <code>version</code> 的方法，原理是构建很多 <code>epoch</code>，其中最新的 <code>epoch</code> 被称为 <code>active epoch</code>，其他的 <code>epoch</code> 按照 <code>FIFO</code> 的方式构成队列。每个 <code>epoch</code> 维护一个计数器，当一个新的事务运行时，<code>active epoch</code> 计数器 +1，当事务运行结束时（commit or abort）其关联的 <code>epoch</code> 计数器 -1。当一个非 <code>active</code> 的 <code>epoch</code> 计数器 = 0 时，并且其之前的所有 <code>epoch</code> 没有绑定正在运行的事务，那么这时可以安全回收在这个 <code>epoch</code> 更新过的无用 <code>version</code> 。</p><p>一般存在两种 <code>GC</code> 的实现方法：这两种方法主要区别在于如何发现无用 <code>version</code></p><ol><li><strong>Tuple-level GC</strong>：对每个 <code>tuple</code> 检查 <code>version</code> 是否过期。具体有两种方案：1. 定期扫所有 <code>tuple</code>；2. 在事务运行查找 <code>version</code> 链表时检查（仅适用于 <code>O2N</code> 结构）</li><li><strong>Transaction-level GC</strong>：检查对象是一个事务中的创建的 <code>version</code>，当所有在事务 <code>T</code> 中被创建的 <code>versions</code> 对所有正在运行的事务不可见时那么称这个事务 <code>T</code> 过期了，其中的 <code>version</code> 被标记为无用</li></ol><p><img src=../../resources/md_imgs/mvcc_gc.png alt></p><h3 id=4-index>4. Index</h3><p>索引分为主索引和二级索引，索引有 <code>key</code>、<code>value</code>，<code>value</code> 一般为指针
<strong>主索引</strong>：<code>key</code> 为主键、<code>value</code> 为 <code>tuple</code>，索引更新根据不同的 <code>version storage</code> 不同，并且 <code>value</code> 不会改变
<strong>二级索引</strong>：<code>key</code> 为任意 <code>table</code> 列项，<code>value</code> 也可以改变包含多个不同的 <code>tuple</code></p><p>这里主要针对二级索引有不同的方法：</p><ol><li><strong>Logical Pointer</strong>：<code>value</code> 指向一个中间层，中间层提供为每个 <code>tuple</code> 设置一个 <code>identifier</code> 到 <code>tuple</code> 的 <code>version</code> 链表 <code>HEAD</code> 的映射关系，二级索引的 <code>value</code> 指向这个 <code>identifier</code></li><li><strong>Physical Pointer</strong>：<code>value</code> 指向实际 <code>version tuple</code> 的地址</li></ol><p><img src=../../resources/md_imgs/mvcc_index.png alt></p><h3 id=总结>总结</h3><p>论文上提供的一些流行 <code>DBMS</code> 的 <code>MVCC</code> 的实现
<img src=../../resources/md_imgs/mvcc_dbms_impl.png alt></p><h2 id=mvcc-与隔离性isolation>MVCC 与隔离性(isolation)</h2><h3 id=隔离性>隔离性</h3><blockquote><ol><li>In database systems, isolation determines how transaction integrity is visible to other users and systems.</li><li>Isolation is typically defined at database level as a property that defines how or when the changes made by one operation become visible to others.</li></ol></blockquote><p>这两句话是维基百科上对于 <code>isolation</code>（隔离性）的一个定义：</p><ol><li>隔离性决定一个事务对于其他用户/系统的可见性</li><li>隔离性定义了某个操作造成的数据变化在什么时间、以怎样的方式可以被其他人所见</li></ol><p>当隔离性越弱，其他用户/系统能够在同一时间访问同一个数据的可能性就越大，这里就会造成并发冲突，导致结构不正确。但是隔离性越强就代表并发越低，即事务会被阻塞运行，性能会越差。并发控制算法(如：<code>MVCC</code>)就是为了来解决这里造成的并发冲突并且实现较高的性能。</p><h3 id=事务异常现象>事务异常现象</h3><ol><li><strong>Dirty reads</strong>
一个事务能够看到其他未提交事务已经更新过的数据。</li><li><strong>Non-repeatable reads</strong>
一个事务 <code>T1</code> 重复取相同的<em>一行数据</em>两次，而这行数据在这两次读取期间被其他事务 <code>T2</code> 更新,并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的数据不一致 并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的同一行的数据不一致。</li><li><strong>Phantom reads</strong>
一个事务 <code>T1</code> 重复取相同的<em>一个集合的数据</em>两次，而这期间其他事务 <code>T2</code> 插入新数据到这个集合中或删除这个集合的某个数据，并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的数据集合不一致。</li><li><strong>Write skew</strong>
见前文</li></ol><h3 id=隔离级别ansiios-sql-定义>隔离级别(ANSI/IOS SQL 定义)</h3><ol><li><strong>Serializable</strong>
串行化有两种实现方案：<ol><li>基于锁: 基于锁的方案会让读/写请求串行获取读锁/写锁，并在事务中止时释放锁，同时需要范围锁 来防止 <code>phantom reads</code></li><li>不基于锁: 需要保证当多个并发事务出现 <code>write collision</code> 时，只让其中一个事务提交</li></ol></li><li><strong>Repeatable reads</strong>
和串行化基于锁的方案一样依旧需要读锁/写锁，但是不需要范围锁(即会出现 <code>phantom reads</code>)，同时会出现 <code>write skew</code></li><li><strong>Read committed</strong>
只有写操作才会一直持有写锁直到事务结束，而读锁在读操作结束就已经释放。只不会出现脏读</li><li><strong>Read uncommitted</strong>
所有异常现象都会出现</li></ol><p>思考：MVCC 属于哪一种？</p><h3 id=mvcc-与隔离级别>MVCC 与隔离级别</h3><p><code>MVCC</code> 与隔离级别并没有强绑定关系，<code>PostgreSQL</code> 使用 <code>MVCC</code> <a href=https://www.postgresql.org/docs/current/transaction-iso.html>实现了四种隔离级别</a>，而且它的隔离级别实现和 ANSI/IOS SQL 定义不一样</p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/wu-vldb2017.pdf>《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》</a></li><li><a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)>Wikipedia Isolation</a></li><li><a href=https://stackoverflow.com/questions/48417632/why-write-skew-can-happen-in-repeatable-reads>why-write-skew-can-happen-in-repeatable-reads</a></li><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>Postgresql Transaction Isolation</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://baymaxhwy.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库</a></li><li><a href=https://baymaxhwy.github.io/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6>并发控制</a></li><li><a href=https://baymaxhwy.github.io/tags/%E9%9A%94%E7%A6%BB%E6%80%A7>隔离性</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://baymaxhwy.github.io/>hwy的小窝</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://baymaxhwy.github.io/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>