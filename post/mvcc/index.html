<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>深入理解 MVCC - Baymax - Normal Coder</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="baymax"><meta name=description content="前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细"><meta name=keywords content="Hugo,theme,even"><meta name=generator content="Hugo 0.101.0 with theme even"><link rel=canonical href=https://baymaxhwy.github.io/post/mvcc/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="深入理解 MVCC"><meta property="og:description" content="前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细"><meta property="og:type" content="article"><meta property="og:url" content="https://baymaxhwy.github.io/post/mvcc/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-13T00:00:00+00:00"><meta property="article:modified_time" content="2023-02-13T00:00:00+00:00"><meta itemprop=name content="深入理解 MVCC"><meta itemprop=description content="前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细"><meta itemprop=datePublished content="2023-02-13T00:00:00+00:00"><meta itemprop=dateModified content="2023-02-13T00:00:00+00:00"><meta itemprop=wordCount content="4150"><meta itemprop=keywords content="并发控制,隔离性,"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入理解 MVCC"><meta name=twitter:description content="前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>B-Art</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>B-Art</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>深入理解 MVCC</h1><div class=post-meta><span class=post-time>2023-02-13</span><div class=post-category><a href=/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#mvcc-简介>MVCC 简介</a></li><li><a href=#mvcc-实现>MVCC 实现</a><ul><li><a href=#1-protocol>1. Protocol</a></li><li><a href=#2-version-storage>2. Version Storage</a></li><li><a href=#3-gc>3. GC</a></li><li><a href=#4-index>4. Index</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#mvcc-与隔离性isolation>MVCC 与隔离性(isolation)</a><ul><li><a href=#隔离性>隔离性</a></li><li><a href=#事务异常现象>事务异常现象</a></li><li><a href=#隔离级别ansiios-sql-定义>隔离级别(ANSI/IOS SQL 定义)</a></li><li><a href=#mvcc-与隔离级别>MVCC 与隔离级别</a></li></ul></li><li><a href=#参考资料>参考资料</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=前言>前言</h2><p>印象中第一次看见 <code>MVCC</code> 是在<a href=https://www.amazon.com/Designing-Data-Intensive-Applications-Reliable-Maintainable/dp/1449373321>《DDIA》</a>这本书上，书中 <code>MVCC</code> 是作为解决 <a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads>Non-repeatable Read</a> 问题的解决方法提出的，当时觉得非常<strong>nb</strong>，但是现在细想来其实对其中的实现细节并不清晰，如果让我来实现一个 <code>MVCC</code> 无从下手。而且既然 <code>MVCC</code> 可以解决 <code>Non-repeatable Read</code> 问题，那它能不能解决其他隔离性的问题？如何做到？最近阅读到了<a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/wu-vldb2017.pdf>《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》</a>这篇论文对 <code>MVCC</code> 的实现有了更深入的了解，这篇文章就是我结合论文和自己的一些理解来尝试剖析一下 <code>MVCC</code>。</p><h2 id=mvcc-简介>MVCC 简介</h2><p><code>Multi-Version concurrency control(MVCC)</code> 从名字上看就是一种并发控制算法用以<strong>控制并发读写单一对象时的行为，尽可能减少竞争并保证一定隔离性</strong>。实现的基本原理是同时维护同一个逻辑对象（<code>Logical Object</code>） 不同时间段的逻辑对象，而一个逻辑对象在某个时间段的数据被称为一个 <code>Version</code> ，当对一个对象进行读/写操作时会根据相应的规则返回特定的 <code>Version</code> ，如果对某个对象完成了更新操作并不会直接将更新应用在其访问的 <code>Version</code> 对象上，而且重新创建一个新 <code>Version</code> 对象。</p><h2 id=mvcc-实现>MVCC 实现</h2><p>在论文中将 <code>MVCC</code> 的关键组件分为四个：<code>Protocol</code>、<code>Version Storage</code>、<code>GC（Garbage Collection）</code>和 <code>Index</code>，而 MVCC 所管理的逻辑对象可以是一个事务（<code>Transactions</code>）或者数据表的一行数据（<code>Tuple/Record</code>），一般都是以 <code>tuple</code> 为操作对象，下面都以 <code>tuple</code> 来介绍。<code>tuple</code> 的存储格式如下（不同 <code>protocol</code> 会有所区别）
<img src=/img/mvcc/mvcc_tuple_format.png alt="Tuple 格式"></p><h3 id=1-protocol>1. Protocol</h3><h4 id=mvtotimestamp-ordering>MVTO（Timestamp Ordering）</h4><p><code>MVTO</code> 为每个事务分配一个唯一的时间戳($T_{id}$)，它会中止所有试图读/更新已经被设置 <code>write lock</code> 的 <code>version tuple</code>（当 <code>txn-id</code> 不等于 0 或者自己的 $T_{id}$ 时表示有其他事务持有 <code>write lock</code>）的事务。<code>MVTO</code> 协议的 <code>tuple header</code> 如下：
<img src=/img/mvcc/mvcc_mvto_tuple_header.png alt></p><ol><li>对 <code>tuple A</code> 进行读操作：
a. 搜索 <code>A</code> 的所有 <code>version</code> 中满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts
b. 并且没有其他事务持有该 <code>version</code> 的 <code>write lock</code>，则可以读该 version
c. 如果 read-ts &lt; $T_{id}$ 的话，更新 read-ts = $T_{id}$</li><li>对 <code>tuple B</code> 进行更新：
a. 找到 <code>B</code> 的最新 <code>version</code>（$B_x$），并满足 b、c 条件
b. 没有其他事务持有 <code>write lock</code>
c. $T_{id}$ >= read_ts
d. 如果满足 b、c 条件则创建一个新版本的 tuple $B_{x+1}$，并加写锁 $B_x$，令其 txn-id = $T_{id}$，当事务 <code>commit</code> 时，更新 $B_{x+1}$ 的 begin-ts = $T_{id}$，end-ts = <code>INF</code></li></ol><p>思考：读/更新操作冲突的情况？</p><h4 id=mvoccoptimistic-concurrency-control>MVOCC（Optimistic Concurrency Control）</h4><p><code>MVOCC</code> 将事务分为三个阶段：<code>read phase</code>、<code>validation phase</code>、<code>write phase</code>
<img src=/img/mvcc/mvcc_mvocc_tuple_header.png alt></p><ol><li>read phase：可以进行对 <code>tuple</code> 的读和更新操作
a. 读只需要找到满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts 的 <code>version</code> 就可以读
b. 更新则需要 <code>tuple</code> 最新的 <code>version</code> 没有被加写锁并且同样会和 <code>MVTO</code> 一样创建新的 $B_{x+1}$ 的新 <code>version</code>，并且设置 $B_x.txn-id = T_{id}$（这里新创建的 $B_{x+1}$ 对其他事务<strong>不可见</strong>）</li><li>validation phase：事务 <code>commit</code> 时，为事务重新分配一个时间戳 $T_{commit}$，验证该事务的所有读操作的 <code>tuple</code> 集合是否存在并发的事务在对同一个 <code>tuple</code> 进行更新操作，如果没有则通过验证，否则中止事务</li><li>write phase：将新创建的 <code>versions</code> 正式写入到存储中，并更新其 begin_ts = $T_{commit}$ end_ts = <code>INF</code></li></ol><p>思考：</p><ol><li>读/更新操作冲突的情况？</li><li><code>MVOCC</code> 和 <code>MVTO</code> 的区别？</li></ol><h4 id=mv2pltwo-phase-locking>MV2PL（Two-phase Locking）</h4><p><code>MV2PL</code> 每个事务会<strong>预先申请</strong>好其所需要读/写相关 <code>tuple</code> 的 <code>lock</code>，<code>write lock</code> 是 <code>txn-id</code>，<code>read-lock</code> 是 <code>read-cnt</code>，当事务中止或者提交时再释放所持有的锁
<img src=/img/mvcc/mvcc_mv2pl_tuple_header.png alt></p><ol><li>读 <code>tuple A</code> 获取 <code>read lock</code>：
a. 搜索 <code>A</code> 的所有 <code>version</code> 中满足 begin-ts &lt;= $T_{id}$ &lt;= end-ts
b. 没有其他事务持有该 <code>version</code> 的 <code>write lock</code>，则 <code>read-cnt + 1</code></li><li>更新 <code>tuple B</code> 获取 <code>write lock</code>：
a. 找到 <code>B</code> 最新的 <code>version</code>（$B_x$），满足以下两个条件则获得 $B_x$ 的 <code>write lock</code>
b. 没有其他事务持有 <code>write lock</code>
c. <code>read-cnt = 0</code></li><li>更新 <code>tuple B</code> 会和之前的协议一样创建新的 <code>version</code>($B_{x+1}$)</li><li>事务提交时：<code>DBMS</code> 会分配一个 $T_{commit}$ 去更新被事务新创建的 <code>version.begin-ts</code> 并且释放所有其持有的 lock（read-cnt - 1, txn-id = 0）</li></ol><p>思考：</p><ol><li>读/更新操作冲突的情况？</li><li>和之前两个协议的区别？</li><li>上面这个 <code>MV2PL</code> 有什么问题？</li></ol><h4 id=ssiserialization-snapshot-isolation>SSI（Serialization Snapshot Isolation）</h4><p><code>SSI</code> 是在其他 <code>MVCC</code> (除开 <code>MV2PL</code>) 方法的基础上实现串行化的方法，它的理论基础是为每个之间事务定义 <code>dependency</code> 关系（设存在两个并行事务 <code>T1</code>、<code>T2</code>）:
1. ww-dependency: 两个事务先后对同一个对象 <code>X</code> 进行写入操作
2. wr-dependency：<code>T1</code> 写入 <code>X</code> 后（提交之前） <code>T2</code> 读取 <code>X</code>
3. rw-dependency(也叫 anti-dependency)：<code>T1</code> 读取了 <code>X</code>，<code>T2</code> 写入了一个更新的 <code>X</code></p><p>如果当前正在运行的事务集合中存在连续的两个 <code>anti-dependecy</code> 并且 <code>dependecy</code> 成环就可能出现异常现象，<code>SSI</code> 就是追踪 <code>anti-dependency</code> 如果发现连续的就中止其中一个事务（会重试事务），具体细节可参考论文 <a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/p1850_danrkports_vldb2012.pdf title="Serializable Snapshot Isolation in PostgreSQL">《Serializable Snapshot Isolation in PostgreSQL》</a></p><p><strong>write-skew(写倾斜)</strong>
在 MVCC 中不能保证串行化的协议天然会存在 write-skew 的情况，例如：当前两个医生值班，每天需要满足至少一个医生在岗值班其他医生才能请假，这时并发两个事务分别对两个医生进行请假，他们都先读取到了一个 <code>version</code> （有两个人值班），满足条件，然后都请假成功，最终不满足值班条件。
<img src=/img/mvcc/mvcc_write_skew.png width=500 height=400></p><p>思考：</p><ol><li><code>SSI</code> 和 <code>MV2PL</code> 的区别？</li></ol><h3 id=2-version-storage>2. Version Storage</h3><p><code>Version Storage</code> 是解决如何存储同一个 <code>tuple</code> 的多个 <code>version</code>，不同的方法之间对于读写性能的影响也不同，这里主要介绍四种方法。
<img src=/img/mvcc/mvcc_version_storage.png alt></p><ol><li><strong>Append-only Storage</strong>: 每个 <code>table</code> 中的所有 <code>tuple version</code> 都存储在同一空间中，同一个 <code>tuple</code> 的不同 <code>version</code> 构成单向链表（方便实现 <code>lock-free</code>），根据链表 <code>HEAD</code> 指向的 <code>version</code> 不同可以分为：<code>O2N</code>（Oldest-to-Newest） 和 <code>N2O</code> （Newest-to-Oldest）
a. <code>O2N</code>：<code>HEAD</code> 指向最旧的 <code>version</code>，优点：新增 <code>version</code> 时不需要更新 <code>index</code>，缺点：查询最新 <code>version</code> 需要遍历链表
b. <code>N2O</code>：<code>HEAD</code> 指向最新的 <code>version</code>，优点：查询最新 <code>version</code> 很快，缺点：新增 <code>version</code> 时需要更新 <code>index</code>
<code>Append-only</code> 的缺点：<code>version</code> 冗余复制了尚未修改的数据项</li><li><strong>Time-Travel Storage</strong>：这种方法将老旧的 <code>version</code> 另外放在一个 <code>time-travel table</code> 中存储，只有最新的 <code>version</code> 存储在 <code>main</code> <code>table</code> 中，每次创建新的 <code>version</code> 就在 <code>time-travel table</code> 中创建一个新的 <code>version</code> 将 <code>main table</code> 中的 <code>version</code> 复制，然后将修改直接应用在 <code>main table</code> 的 <code>version</code> 上（<code>time-travel table</code> 中的 <code>version</code> 也是链表形式存储）
优点：不需要更新 <code>index</code>，查询最新的 <code>version</code> 很快
缺点：和 <code>Append-only</code> 一样存在冗余复制</li><li><strong>Delta Storage</strong>：和 <code>Time-Travel</code> 类似最新的 <code>version</code> 存储在 <code>main table</code> 中，其他 <code>version</code>（被称为 <code>Delta version</code>）存储在 <code>delta table</code> 中，但是仅存储被修改的数据项
优点：对于更新操作频繁的更节省空间
缺点：对于读操作需要遍历 <code>delta table</code> 链表来获取完整的 <code>tuple</code>（非最新）</li></ol><h3 id=3-gc>3. GC</h3><p><code>MVCC</code> 会无限制的创建 <code>version</code> 最终导致超出存储空间，因此需要 <code>GC</code> 来及时回收哪些无用的 <code>version</code> 所占用的存储空间。</p><blockquote><p>无用的 version：1. 属于被中止的事务；2. end-ts 小于所有正在运行事务的 $T_{id}$。</p></blockquote><p><code>GC</code> 运行可以分为三步：1. 检测出无用 <code>version</code>；2. 将 <code>version</code> 从其所属的 <code>version</code> 链表中移除并更新索引；3. 回收 <code>version</code> 存储空间</p><p>主要的设计难点在于如何快速有效的检测出无用 <code>version</code> 减少 <code>GC</code> 运行时间</p><p><strong>Epoch-Based memory management</strong>：是一种粗力度的追踪 <code>version</code> 的方法，原理是构建很多 <code>epoch</code>，其中最新的 <code>epoch</code> 被称为 <code>active epoch</code>，其他的 <code>epoch</code> 按照 <code>FIFO</code> 的方式构成队列。每个 <code>epoch</code> 维护一个计数器，当一个新的事务运行时，<code>active epoch</code> 计数器 +1，当事务运行结束时（commit or abort）其关联的 <code>epoch</code> 计数器 -1。当一个非 <code>active</code> 的 <code>epoch</code> 计数器 = 0 时，并且其之前的所有 <code>epoch</code> 没有绑定正在运行的事务，那么这时可以安全回收在这个 <code>epoch</code> 更新过的无用 <code>version</code> 。</p><p>一般存在两种 <code>GC</code> 的实现方法：这两种方法主要区别在于如何发现无用 <code>version</code></p><ol><li><strong>Tuple-level GC</strong>：对每个 <code>tuple</code> 检查 <code>version</code> 是否过期。具体有两种方案：1. 定期扫所有 <code>tuple</code>；2. 在事务运行查找 <code>version</code> 链表时检查（仅适用于 <code>O2N</code> 结构）</li><li><strong>Transaction-level GC</strong>：检查对象是一个事务中的创建的 <code>version</code>，当所有在事务 <code>T</code> 中被创建的 <code>versions</code> 对所有正在运行的事务不可见时那么称这个事务 <code>T</code> 过期了，其中的 <code>version</code> 被标记为无用</li></ol><p><img src=/img/mvcc/mvcc_gc.png alt></p><h3 id=4-index>4. Index</h3><p>索引分为主索引和二级索引，索引有 <code>key</code>、<code>value</code>，<code>value</code> 一般为指针
<strong>主索引</strong>：<code>key</code> 为主键、<code>value</code> 为 <code>tuple</code>，索引更新根据不同的 <code>version storage</code> 不同，并且 <code>value</code> 不会改变
<strong>二级索引</strong>：<code>key</code> 为任意 <code>table</code> 列项，<code>value</code> 也可以改变包含多个不同的 <code>tuple</code></p><p>这里主要针对二级索引有不同的方法：</p><ol><li><strong>Logical Pointer</strong>：<code>value</code> 指向一个中间层，中间层提供为每个 <code>tuple</code> 设置一个 <code>identifier</code> 到 <code>tuple</code> 的 <code>version</code> 链表 <code>HEAD</code> 的映射关系，二级索引的 <code>value</code> 指向这个 <code>identifier</code></li><li><strong>Physical Pointer</strong>：<code>value</code> 指向实际 <code>version tuple</code> 的地址</li></ol><p><img src=/img/mvcc/mvcc_index.png alt></p><h3 id=总结>总结</h3><p>论文上提供的一些流行 <code>DBMS</code> 的 <code>MVCC</code> 的实现
<img src=/img/mvcc/mvcc_dbms_impl.png alt></p><h2 id=mvcc-与隔离性isolation>MVCC 与隔离性(isolation)</h2><h3 id=隔离性>隔离性</h3><blockquote><ol><li>In database systems, isolation determines how transaction integrity is visible to other users and systems.</li><li>Isolation is typically defined at database level as a property that defines how or when the changes made by one operation become visible to others.</li></ol></blockquote><p>这两句话是维基百科上对于 <code>isolation</code>（隔离性）的一个定义：</p><ol><li>隔离性决定一个事务对于其他用户/系统的可见性</li><li>隔离性定义了某个操作造成的数据变化在什么时间、以怎样的方式可以被其他人所见</li></ol><p>当隔离性越弱，其他用户/系统能够在同一时间访问同一个数据的可能性就越大，这里就会造成并发冲突，导致结构不正确。但是隔离性越强就代表并发越低，即事务会被阻塞运行，性能会越差。并发控制算法(如：<code>MVCC</code>)就是为了来解决这里造成的并发冲突并且实现较高的性能。</p><h3 id=事务异常现象>事务异常现象</h3><ol><li><strong>Dirty reads</strong>
一个事务能够看到其他未提交事务已经更新过的数据。</li><li><strong>Non-repeatable reads</strong>
一个事务 <code>T1</code> 重复取相同的<em>一行数据</em>两次，而这行数据在这两次读取期间被其他事务 <code>T2</code> 更新,并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的数据不一致 并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的同一行的数据不一致。</li><li><strong>Phantom reads</strong>
一个事务 <code>T1</code> 重复取相同的<em>一个集合的数据</em>两次，而这期间其他事务 <code>T2</code> 插入新数据到这个集合中或删除这个集合的某个数据，并且 <code>T2</code> 在 <code>T1</code> 第二次读取之前已经提交，这时 <code>T1</code> 前后拿到的数据集合不一致。</li><li><strong>Write skew</strong>
见前文</li></ol><h3 id=隔离级别ansiios-sql-定义>隔离级别(ANSI/IOS SQL 定义)</h3><ol><li><strong>Serializable</strong>
串行化有两种实现方案：<ol><li>基于锁: 基于锁的方案会让读/写请求串行获取读锁/写锁，并在事务中止时释放锁，同时需要范围锁 来防止 <code>phantom reads</code></li><li>不基于锁: 需要保证当多个并发事务出现 <code>write collision</code> 时，只让其中一个事务提交</li></ol></li><li><strong>Repeatable reads</strong>
和串行化基于锁的方案一样依旧需要读锁/写锁，但是不需要范围锁(即会出现 <code>phantom reads</code>)，同时会出现 <code>write skew</code></li><li><strong>Read committed</strong>
只有写操作才会一直持有写锁直到事务结束，而读锁在读操作结束就已经释放。只不会出现脏读</li><li><strong>Read uncommitted</strong>
所有异常现象都会出现</li></ol><p>思考：MVCC 属于哪一种？</p><h3 id=mvcc-与隔离级别>MVCC 与隔离级别</h3><p><code>MVCC</code> 与隔离级别并没有强绑定关系，<code>PostgreSQL</code> 使用 <code>MVCC</code> <a href=https://www.postgresql.org/docs/current/transaction-iso.html>实现了四种隔离级别</a>，而且它的隔离级别实现和 ANSI/IOS SQL 定义不一样</p><h2 id=参考资料>参考资料</h2><ol><li><a href=https://15721.courses.cs.cmu.edu/spring2020/papers/03-mvcc1/wu-vldb2017.pdf>《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》</a></li><li><a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)>Wikipedia Isolation</a></li><li><a href=https://stackoverflow.com/questions/48417632/why-write-skew-can-happen-in-repeatable-reads>why-write-skew-can-happen-in-repeatable-reads</a></li><li><a href=https://www.postgresql.org/docs/current/transaction-iso.html>Postgresql Transaction Isolation</a></li></ol></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>baymax</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2023-02-13</span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/>并发控制</a>
<a href=/tags/%E9%9A%94%E7%A6%BB%E6%80%A7/>隔离性</a></div><nav class=post-nav><a class=next href=/post/mit6.824-raft/><span class="next-text nav-default">Raft总结</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=social-links><a href=heweiyu.me@gmail.com class="iconfont icon-email" title=email></a>
<a href=https://github.com/BaymaxHWY class="iconfont icon-github" title=github></a>
<a href=https://baymaxhwy.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2020 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>baymax</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>