<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Raft总结 - hwy的小窝</title><meta name=description content="前言 这里是对MIT6.824课程中有关Raft部分的一些总结（包括一些个人的理解以及Lab2的实现思路等）。首先还是很感谢MIT的大牛们能把这门神课开源出来，让更多的人能更加系统的学习分布式系统（搭配《DDIA》效果更佳！）。
简介 因为需要遵守 Collaboration Policy 不能公布全部代码，主要是思路和伪代码。
Raft是一个用于管理副本log的共识算法，它的功能类似于Paxos，但是比Paxos更简单（相对而言），更容易让人去理解学习，也容易在现实中实现。Raft主要有这几部分：领导选举、日志复制、集群变更、日志持久化、快照，本文只讨论与Lab2有关的部分。
共识算法&mdash;详细可以去看书 在6.824课程和《Raft》论文中对共识的阐释没有系统具体的阐释，这里主要是引用《DDIA》中的关于共识的部分内容：
共识问题是分布式计算中最重要也是最基本的问题之一。共识其实就是让几个节点就某件事情达成一致。这样表面上看去不是太难，但是因为分布式系统本身就是不可靠的，存在各种问题、失败、故障（网络故障、进程暂停、时钟问题等），想让多个节点到达共识其实是存在很大的难度。
共识算法需要满足一些性质：
协商一致性（Uniform agreement）：所有节点都接受相同的决议 诚实性（Integrity）：所有节点不能反悔，即对一项提议不能有两次决定 合法性（Validity）：如果决定了值v，则v一定由某个节点所提议 可终止性（Termination）：节点如果不崩溃则最终一定可以达成协议 协商一致性和诚实性决定了共识算法的核心思想：决定一致的结果，一旦决定，就不能改变。合法性（有效性，书里面会混用，属于翻译问题）则是排除一些无意义的方案，例如值为空（NULL）。前三个主要是保障了安全性（Safety），而可终止性则是引入了容错的思想。
2PC，两阶段提交也是共识算法但是不具有容错性，因为它的leader（独裁者、协调者）是人为指定的，也就没有可终止性，如果协调者故障则系统会一直原地空转
最著名的容错共识算法包括：VSR、Paxos、Raft和Zab（Zookeeper），他们大都不是直接使用上面的形式化描述。相反，他们是决定了一系列值，然后采用全序关系广播算法。
具体实现（思路和伪代码） 领导选举（Lab2A） 领导选举其实就是一次共识的过程，需要一个Candidate节点发起election让其与的节点来进行投票（vote）。
首先这里先介绍一下Raft中每个节点能够扮演的角色：
Follower：只负责接收Leader、Candidate的请求来进行响应，自身无法主动发起任何请求，但是会有一个election time，如果到期则会成为Candidate节点 Candidate：自身的term+1，重置election time，启动一个election vote活动，向集群中的所有节点发送vote请求，如果能在下一次election time到期之前获得大多数（Majority）节点的投票则会成为Leader（Candidate自己会投给自己），否则会开启新一轮的election Leader：每个term最多只有一个Leader，Leader会定时向集群中的节点发送心跳包来阻止新一轮的选举，同时会接受client的请求并复制到Follower节点 领导选举的整个流程：
首先所有节点初始化为Follower状态，并且设置election time（注意为了防止出现多个Candidate 的情况，需要在指定区间内随机time的值）
当time out时某个Follower会成为Candidate，开启一轮选举，如果获得大多数投票则选举成功，成为Leader，否则等待下一次time out开启新一轮选举。
Leader会以更短（比election time）的时间间隔向其他节点发送心跳包防止进行新选举
基本上需要按照论文中Figure2中的表示进行编写代码，不然容易出bug。这里需要注意的一点：
代码主要分为三部分：Election time超时机制，Candidate发起选举，RequestVote RPC处理
Election time超时机制。 首先每个Raft实例都会启动一个attemptElection的goroutine
func (rf *Raft) attemptElection() { for !rf.killed() { timeout := getRandTime() // 预定超时时间 time.Sleep(timeout) if time.Since(rf.lastHeartMsg) > timeout && rf.state != Leader { rf."><meta name=author content="Baymax_hwy"><link href=https://baymaxhwy.github.io/an-old-hope.min.css rel=stylesheet><link href=https://baymaxhwy.github.io/style.css rel=stylesheet><link rel=apple-touch-icon href=https://baymaxhwy.github.io/apple-touch-icon.png><link rel=icon href=https://baymaxhwy.github.io/favicon.ico><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/atom+xml href=https://baymaxhwy.github.io/index.xml title=hwy的小窝><script>function setTheme(){const n=new Date,a=localStorage.getItem("date"),s=String(n.getMonth()+1)+"."+String(n.getDate()),o=n.getTime();let e,t;function i(){if(o>e&&o<t)return;document.body.classList.add("dark")}s!==a?(fetch("https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215").then(e=>e.json()).then(n=>{e=n.sunrise.split(":").map(Number),t=n.sunset.split(":").map(Number)}).catch(()=>{e=[7,0],t=[19,0]}).finally(()=>{e=n.setHours(e[0],e[1],0),t=n.setHours(t[0],t[1],0),i(),localStorage.setItem("sunrise",e),localStorage.setItem("sunset",t)}),localStorage.setItem("date",s)):(e=Number(localStorage.getItem("sunrise")),t=Number(localStorage.getItem("sunset")),i())}</script></head><body class=single><script>setTheme()</script><header class=header><nav class=nav><p class=logo><a href=https://baymaxhwy.github.io/>hwy的小窝</a></p><ul class=menu><li><a href=/posts/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Raft总结</h1><div class=post-meta>Baymax_hwy · April 22, 2020</div></header><div class=post-content><h2 id=前言>前言</h2><p>这里是对MIT6.824课程中有关Raft部分的一些总结（包括一些个人的理解以及Lab2的实现思路等）。首先还是很感谢MIT的大牛们能把这门神课开源出来，让更多的人能更加系统的学习分布式系统（搭配《DDIA》效果更佳！）。</p><h2 id=简介>简介</h2><blockquote><p>因为需要遵守 Collaboration Policy 不能公布全部代码，主要是思路和伪代码。</p></blockquote><p>Raft是一个用于管理副本log的共识算法，它的功能类似于Paxos，但是比Paxos更简单（相对而言），更容易让人去理解学习，也容易在现实中实现。Raft主要有这几部分：领导选举、日志复制、集群变更、日志持久化、快照，本文只讨论与Lab2有关的部分。</p><h3 id=共识算法---详细可以去看书>共识算法&mdash;详细可以去看书</h3><blockquote><p>在6.824课程和《Raft》论文中对共识的阐释没有系统具体的阐释，这里主要是引用《DDIA》中的关于共识的部分内容：</p></blockquote><p>共识问题是分布式计算中最重要也是最基本的问题之一。共识其实就是让几个节点就某件事情达成一致。这样表面上看去不是太难，但是因为分布式系统本身就是不可靠的，存在各种问题、失败、故障（网络故障、进程暂停、时钟问题等），想让多个节点到达共识其实是存在很大的难度。</p><p>共识算法需要满足一些性质：</p><ul><li>协商一致性（Uniform agreement）：所有节点都接受相同的决议</li><li>诚实性（Integrity）：所有节点不能反悔，即对一项提议不能有两次决定</li><li>合法性（Validity）：如果决定了值v，则v一定由某个节点所提议</li><li>可终止性（Termination）：节点如果不崩溃则最终一定可以达成协议</li></ul><p>协商一致性和诚实性决定了共识算法的核心思想：<strong>决定一致的结果，一旦决定，就不能改变</strong>。合法性（有效性，书里面会混用，属于翻译问题）则是排除一些无意义的方案，例如值为空（NULL）。前三个主要是保障了安全性（Safety），而可终止性则是引入了容错的思想。</p><blockquote><p>2PC，两阶段提交也是共识算法但是不具有容错性，因为它的leader（独裁者、协调者）是人为指定的，也就没有可终止性，如果协调者故障则系统会一直原地空转</p></blockquote><p>最著名的容错共识算法包括：VSR、Paxos、Raft和Zab（Zookeeper），他们大都不是直接使用上面的形式化描述。相反，他们是决定了一系列值，然后采用全序关系广播算法。</p><h2 id=具体实现思路和伪代码>具体实现（思路和伪代码）</h2><h3 id=领导选举lab2a>领导选举（Lab2A）</h3><p>领导选举其实就是一次共识的过程，需要一个Candidate节点发起election让其与的节点来进行投票（vote）。</p><ol><li><p>首先这里先介绍一下Raft中每个节点能够扮演的角色：</p><ul><li>Follower：只负责接收Leader、Candidate的请求来进行响应，自身无法主动发起任何请求，但是会有一个election time，如果到期则会成为Candidate节点</li><li>Candidate：自身的term+1，重置election time，启动一个election vote活动，向集群中的所有节点发送vote请求，如果能在下一次election time到期之前获得大多数（Majority）节点的投票则会成为Leader（Candidate自己会投给自己），否则会开启新一轮的election</li><li>Leader：每个term最多只有一个Leader，Leader会定时向集群中的节点发送心跳包来阻止新一轮的选举，同时会接受client的请求并复制到Follower节点</li></ul></li><li><p>领导选举的整个流程：</p><p><img src=https://images-1253801505.cos.ap-nanjing.myqcloud.com/blog/image-20200419130504004.png alt></p><ul><li><p>首先所有节点初始化为Follower状态，并且设置election time（注意为了防止出现多个Candidate 的情况，需要在指定区间内随机time的值）</p></li><li><p>当time out时某个Follower会成为Candidate，开启一轮选举，如果获得大多数投票则选举成功，成为Leader，否则等待下一次time out开启新一轮选举。</p></li><li><p>Leader会以更短（比election time）的时间间隔向其他节点发送心跳包防止进行新选举</p></li></ul></li></ol><p>基本上需要按照论文中Figure2中的表示进行编写代码，不然容易出bug。这里需要注意的一点：</p><p>代码主要分为三部分：Election time超时机制，Candidate发起选举，<code>RequestVote</code> RPC处理</p><h4 id=election-time超时机制>Election time超时机制。</h4><p>首先每个Raft实例都会启动一个<code>attemptElection</code>的goroutine</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>attemptElection</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>killed</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>timeout</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getRandTime</span>() <span style=color:#75715e>// 预定超时时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastHeartMsg</span>) &gt; <span style=color:#a6e22e>timeout</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Leader</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>			<span style=color:#75715e>// 进行选举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>kickOffElection</span>()
</span></span><span style=display:flex><span>		} 
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>timeout</code>是在一个指定时间区间里一个随机值。</p><p>由于Lab2的讲义中建议不要使用<code>time.Timer</code> 或者 <code>time.Ticker</code>（因为容易出错），所以这里我使用用<code>time.Sleep</code>，并且会用<code>lastHeartMsg</code>来记录上一次更新的时间，用<code>time.Now() - lastHeartMsg</code>再和预定的超时时间（<code>timeout</code>）来进行比较。</p><p>这里有个小问题就是当该Raft节点成为Leader后这个goroutine还是会继续执行，但是不影响整体的结果，对于效率而言该goroutine大部分时间处理休眠状态不占用CPU，所以为了代码逻辑的简洁就这样实现了（其实是懒）</p><h4 id=candidate发起选举>Candidate发起选举。</h4><p>关于开启一轮新的选举的实现思路：</p><ul><li>首先需要更新节点的信息和状态（term、Candidate和votefor）</li><li>并发的向除自己外的所有节点发送请求</li><li>当获得大多数投票时停止其他请求（未完成），成为Leader</li></ul><p>这里的难点主要是并发发送请求，我的实现方式是遍历所有节点peer，对每个peer启动一个goroutine进行发送请求以及投票计数和leader转化</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>peers</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>me</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>accept</span>, <span style=color:#a6e22e>acceptTerm</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>callRequestVote</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>term</span>, <span style=color:#a6e22e>lastLogIndex</span>, <span style=color:#a6e22e>lastLogTerm</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>acceptTerm</span> <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> { <span style=color:#75715e>// call rpc fail
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>accept</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>acceptTerm</span> &gt; <span style=color:#a6e22e>term</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>convertToFollower</span>(<span style=color:#a6e22e>acceptTerm</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>voteCnt</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>voteCnt</span> <span style=color:#f92672>&lt;=</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>peers</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 需要二次检查
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Candidate</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>term</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>convertToLeader</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里需要注意的是在发送请求进行rpc调用的时候不能加锁，不然可能这个rpc一直阻塞那么整个节点都会一直处于加锁状态。这里关于投票计数有两种方式（我了解到），一种是上述直接在每个goroutine中利用闭包的特性进行计数（不过需要加锁），另一种是使用条件变量<code>sync.Cond</code>在外部进行统计（个人觉得第一种方式更加简单）。</p><p>在转化成Leader时需要特判一下该节点是否还是Candidate以及currentTerm是否是发起这轮选举时记录的那个term，导致这种情况可能是因为这个Candidate已经成为了Follower或者因为网络延迟开启了新的一轮选举（接收到了上一轮请求的回复）</p><h4 id=requestvoterpc的处理><code>RequestVote</code>RPC的处理。</h4><p>主要就是确认是否要投票给这个Candidate。首先可以明确拒绝的情况有：</p><ul><li><code>args.Term &lt;= currentTerm</code></li><li>如果Candidate的日志没有比自己的日志<strong>up-to-date</strong>的话，即：比较最后一个log的term，如果相等则比较log的长度</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lastLog</span>.<span style=color:#a6e22e>Term</span> &gt; <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>lastLog</span>.<span style=color:#a6e22e>Term</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> &gt; <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogIndex</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>reply</span>.<span style=color:#a6e22e>VoteGranted</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里有个需要注意的点就是关于该Raft节点的Election time的重置时机，需要时确定要投票给这个Candidate才要去重置，不然会导致日志比较落后的节点一直发起选举，而拥有最新日志的节点则一直被重置，最终无法选择出一个Leader</p><p>关于<code>RequestVote</code>RPC的处理中，不能投票给<code>args.Term == rf.currentTerm</code>的Candidate，不然可能会出现两个不断交替的Leader（由于某条网络连接故障）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>RequestVote</span>(<span style=color:#a6e22e>args</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestVoteArgs</span>, <span style=color:#a6e22e>reply</span> 	<span style=color:#f92672>*</span><span style=color:#a6e22e>RequestVoteReply</span>) {
</span></span><span style=display:flex><span> <span style=color:#75715e>// 检查term
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Term</span> {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 拒绝投票
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#75715e>// 检查candidate的log是否比自己的更 up-to-date
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>lastLog</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>[len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>lastLog</span>.<span style=color:#a6e22e>Term</span> &gt; <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> <span style=color:#f92672>||</span> (<span style=color:#a6e22e>lastLog</span>.<span style=color:#a6e22e>Term</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogTerm</span> <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> &gt; <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>LastLogIndex</span>) {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 拒绝投票
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#75715e>// 投票给Candidate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span></code></pre></div><h3 id=日志复制lab2b>日志复制（Lab2B）</h3><p>日志复制主要可以分为这么几个部分：</p><ol><li><p>接收上层的command命令；</p></li><li><p>Leader的心跳包和日志同步；</p></li><li><p><code>AppendEntries</code>RPC的处理；</p></li><li><p>应用日志结果（通知上层可以应用该command）</p></li></ol><p>日志复制需要实现：</p><ol><li>只有<code>commited</code>的日志项才能被上层程序应用；</li><li>只有被大多数节点复制备份的日志项才能被标记为<code>commited</code></li><li>需要保证所有节点的日志项被上层程序应用的顺序相同（这样才能保证所有节点最终会达到相同的state）</li></ol><p>日志复制示意图：</p><p><img src=https://images-1253801505.cos.ap-nanjing.myqcloud.com/blog/image-20200420154327676.png alt></p><h4 id=接收上层的command命令>接收上层的command命令</h4><p>这部分主要是完善Lab中已经给出的<code>Start</code>方法，需要定义一下日志（log）的数据结构，然后要注意只有Leader的节点才能执行<code>Start</code>方法，然后将上层给出的<code>command</code>构造成一个日志项加入到该节点的日志中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>state</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Leader</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>index</span> = len(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>term</span> = <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>isLeader</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span> = append(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>, <span style=color:#a6e22e>LogEntry</span>{
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Term</span>:    <span style=color:#a6e22e>term</span>,
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Command</span>: <span style=color:#a6e22e>command</span>,
</span></span><span style=display:flex><span>			})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=leader的心跳包和日志同步复制>Leader的心跳包和日志同步（复制）</h4><ol><li>心跳包主要是为了及时的重置其他节点（非Leader节点）的election time，防止发生新一轮的选举</li><li>日志同步是夹杂在心跳包之中（换句话说如果<code>AppendEntries</code>RPC的<code>args.Entries</code>属性为空就是心跳包，否则就是日志同步）</li></ol><blockquote><p>关于什么时候应该进行日志同步？</p></blockquote><p>在每一次心跳time到期的时候需要向其他所有节点并发发送请求（开goroutine进行RPC调用），这里在对于某个节点（编号<code>x</code>）发送之前需要检查对比一下<code>nextIndex[x]</code>和<code>log</code>的最后一项下标的大小，如果<code>log</code>最后一项下标<code>>= nextIndex[x]</code>则需要进行日志同步</p><p>这里有一个坑：就是当节点<code>x</code>日志同步成功时，关于更新<code>nextIndex[x]</code>和<code>matchIndex[x]</code>，不能直接将<code>nextIndex[x]</code>的值直接更新为<code>len(log)-1</code>因为在rpc调用的过程中这个节点是没有加锁的，那么<code>log</code>的长度可能会增加，所以应该用<code>len(args.Entries) + args.PrevLogIndex</code>来更新<code>nextIndex[x]</code>和<code>matchIndex[x]</code></p><p>当节点<code>x</code>日志同步失败（如果当前Leader节点已经<strong>退位</strong>的话就直接成为Follower，这里不讨论这种情况）的时候需要回滚<code>nextIndex[x]</code>，有很多方法，本文主要说两种：一项一项的回滚，快速回滚</p><ul><li><p>一项一项的回滚就是如果节点<code>x</code>调用失败，直接<code>nextIndex[x]--</code></p></li><li><p>快速回滚，在论文中只是稍微提及（作者似乎觉得不必要），但是<strong>Robert Tappan Morris</strong>教授（传奇大牛）课上说如果不进行快速回滚效率会很低（特别是当某个节点宕机很长时间后再进行日志同步），而且会过不了lab test。这里才用了<a href=https://thesquareplanet.com/blog/students-guide-to-raft/>TA的blog</a>中提起的方法：</p><ul><li><code>AppendEntries</code>当失败时会在<code>reply</code>中设置两个变量<code>ConflictTerm</code>和<code>ConflictIndex</code></li><li>首先在本节点<code>log</code>中查找是否有<code>log的term == ConflictTerm</code>，如果存在则将该<code>log中属于该term</code>的最后一项下标设置为<code>nextIndex[x]</code></li><li>如果没有找到则设置<code>nextIndex[x] = ConflictIndex</code></li></ul><p>关于<code>ConflictTerm</code>和<code>ConflictIndex</code>的设置在<code>AppendEntries</code>的处理会说明</p></li></ul><p>如果当日志同步到大多数节点时，Leader节点会更新自己的<code>commitIndex</code>，其值根据<code>matchIndex</code>数组决定，然后下一次心跳包发送的时候就带上这个<code>commitIndex</code></p><p><em>这部分是lab中的核心，很有意思就不贴代码了，每个人可以自己去设计自己的方案</em></p><h4 id=appendentriesrpc的处理><code>AppendEntries</code>RPC的处理</h4><p><code>AppendEntries</code>的处理主要分为三个部分：<code>log</code>一致性检查；<code>args.Entries</code>处理；更新<code>commitIndex</code></p><ul><li><code>log</code>一致性检查。主要是根据<code>PrevLogIndex</code>和<code>PrevLogTerm</code>检查自己和Leader的<code>log</code>是否一致（<code>args.Entries</code>之前的部分）<ul><li>如果本节点的<code>len(log) &lt;= PrevLogIndex</code>则说明不一致，并且设置<code>ConflictTerm = null，ConflictIndex = len(log)</code></li><li>如果本节点在<code>PrevLogIndex</code>位置上的<code>term != ConflictTerm </code>，则将<code>ConflictTerm = term</code>并且将<code>ConflictIndex</code>设置为<code>ConflictTerm</code>的第一项的索引下表</li></ul></li><li><code>args.Entries</code>处理。通过一致性检查的话，需要对<code>Entries</code>做两件事情：将本节点<code>log</code>中与<code>Entries</code>不一致的项给截断，同时需要过滤掉本节点<code>log</code>中已经存在的项（过滤重复项，主要是因为网络延迟等问题可能会接收到多个相同的请求）</li><li>更新<code>commitIndex</code>。通过一致性检查的话，如果<code>LeaderCommitIndex > 本节点的commitIndex</code>，那么需要更新本节点的<code>commitIndex</code>，这里需要注意不能直接更新成<code>LeaderCommitIndex</code>因为可能其值会大于本节点<code>len(log)</code>即<code>args.PrevLogIndex + len(args.Entries)</code>，所以需要更新为其中较小的那个值</li></ul><p><em>这部分是lab中的核心，很有意思就不贴代码了，每个人可以自己去设计自己的方案</em></p><h4 id=应用日志结果>应用日志结果</h4><p>应用日志结果在Lab2中就是将已经标记为<code>commited</code>的日志项通过<code>channel applyCh</code>进行传输。这里有一个属性<code>lastApplied</code>记录已经应用的项（防止重复传输）</p><p><code>lastApplied</code>的更新是通过比较<code>commitIndex</code>来更新，如果<code>rf.commitIndex > rf.lastApplied</code>则<code>rf.lastApplied += 1</code>，将<code>log[rf.lastApplied]</code>处的项传入<code>applyCh</code>通道中</p><p>这个和election time倒计时以及Leader的定时心跳包一样都是需要定时运行（在我的实现中）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> !<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>killed</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>50</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>commitIndex</span> &gt; <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>applyLog</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ApplyMsg</span>{
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>CommandValid</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>Command</span>:      <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>[<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span>].<span style=color:#a6e22e>Command</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>CommandIndex</span>: <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>lastApplied</span>,
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 这里最好不要加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>applyCh</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>applyLog</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=日志持久化lab2c>日志持久化（Lab2C）</h3><blockquote><p>这里的思路和实现都比较简单，如果在2C test失败的话可能是由于2B的部分逻辑问题（比如没有考虑到一些网络阻塞的情况）</p></blockquote><p>Lab2C要求实现<code>persist</code>和<code>readPersist</code>两个方法，而且给出了例子这里就不多说了。在Lab中并没有真正的持久化到硬盘存储中，是在外部使用<code>Persister</code>结构来存储（说白了就是存在内存中，在测试的过程中只是重启了Raft程序的进程，没有重启整个test程序）</p><p>那么2C中只需要考虑<code>persist</code>的使用时机问题，可以分析需要持久化的属性，再根据代码实现中这些值作出变更的时候进行持久化。但是这里就需要注意加锁的问题，因为可能再Raft对应属性变更的时候已经加锁了，而<code>persist</code>又在内部需要加锁，这时候就要记得释放锁</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// persist的实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>persist</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>labgob</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>// 这里进行了加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>votedFor</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>log</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Bytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>persister</span>.<span style=color:#a6e22e>SaveRaftState</span>(<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// persist的应用
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 比如在RequestVote的实现中，可能需要更改本节点的currentTerm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>RequestVote</span>(<span style=color:#a6e22e>args</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestVoteArgs</span>, <span style=color:#a6e22e>reply</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RequestVoteReply</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 一些操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>state</span> = <span style=color:#a6e22e>Follower</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>currentTerm</span> = <span style=color:#a6e22e>args</span>.<span style=color:#a6e22e>Term</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>persist</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 后续操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=总结>总结</h2><p>这是我第二次做6.824，第一次的时候是三个月以前，感觉自己确实进步了很多，实际写代码的时候可能总共就三天吧，但是学到这里却用了将近一个月（自己也比较懒），主要的时间都在读论文、看视频、看相关的资料，因为大部分都是英文（自己英语比较差）所以花了很多时间，但是成效也很明显，英文文献阅读能力提高了很多（虽然还是需要借助翻译工具），这里推荐曹大的一篇<a href=https://xargin.com/how-to-learn/>blog</a></p><h2 id=参考资料>参考资料</h2><ul><li><a href=https://pdos.csail.mit.edu/6.824/schedule.html>mit6.824</a></li><li><a href=https://thesquareplanet.com/blog/students-guide-to-raft/>Students&rsquo; Guide to Raft</a></li><li><a href=https://www.qtmuniao.com/2020/01/18/raft-implement-points/>MIT 6.824 2020 Raft 实现细节备忘</a></li><li><a href=https://mr-dai.github.io/raft/>Raft总结</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://baymaxhwy.github.io/tags/mit6.824>MIT6.824</a></li><li><a href=https://baymaxhwy.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统</a></li><li><a href=https://baymaxhwy.github.io/tags/golang>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://baymaxhwy.github.io/>hwy的小窝</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://baymaxhwy.github.io/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>