<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>数据库 - hwy的小窝</title><meta name=description content><meta name=author content="Baymax_hwy"><link href=https://baymaxhwy.github.io/an-old-hope.min.css rel=stylesheet><link href=https://baymaxhwy.github.io/style.css rel=stylesheet><link rel=apple-touch-icon href=https://baymaxhwy.github.io/apple-touch-icon.png><link rel=icon href=https://baymaxhwy.github.io/favicon.ico><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/atom+xml href=https://baymaxhwy.github.io/index.xml title=hwy的小窝><script>function setTheme(){const n=new Date,a=localStorage.getItem("date"),s=String(n.getMonth()+1)+"."+String(n.getDate()),o=n.getTime();let e,t;function i(){if(o>e&&o<t)return;document.body.classList.add("dark")}s!==a?(fetch("https://api.ipgeolocation.io/astronomy?apiKey=5ed37d85103e4defa5df4c5298ed5215").then(e=>e.json()).then(n=>{e=n.sunrise.split(":").map(Number),t=n.sunset.split(":").map(Number)}).catch(()=>{e=[7,0],t=[19,0]}).finally(()=>{e=n.setHours(e[0],e[1],0),t=n.setHours(t[0],t[1],0),i(),localStorage.setItem("sunrise",e),localStorage.setItem("sunset",t)}),localStorage.setItem("date",s)):(e=Number(localStorage.getItem("sunrise")),t=Number(localStorage.getItem("sunset")),i())}</script></head><body class=list><script>setTheme()</script><header class=header><nav class=nav><p class=logo><a href=https://baymaxhwy.github.io/>hwy的小窝</a></p><ul class=menu><li><a href=/posts/>Blog</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></header><main class=main><header class=page-header><h1>数据库</h1></header><article class=post-entry><header class=entry-header><h2>深入理解 MVCC</h2></header><section class=entry-content><p>前言 印象中第一次看见 MVCC 是在《DDIA》这本书上，书中 MVCC 是作为解决 Non-repeatable Read 问题的解决方法提出的，当时觉得非常nb，但是现在细想来其实对其中的实现细节并不清晰，如果让我来实现一个 MVCC 无从下手。而且既然 MVCC 可以解决 Non-repeatable Read 问题，那它能不能解决其他隔离性的问题？如何做到？最近阅读到了《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》这篇论文对 MVCC 的实现有了更深入的了解，这篇文章就是我结合论文和自己的一些理解来尝试剖析一下 MVCC。
MVCC 简介 Multi-Version concurrency control(MVCC) 从名字上看就是一种并发控制算法用以控制并发读写单一对象时的行为，尽可能减少竞争并保证一定隔离性。实现的基本原理是同时维护同一个逻辑对象（Logical Object） 不同时间段的逻辑对象，而一个逻辑对象在某个时间段的数据被称为一个 Version ，当对一个对象进行读/写操作时会根据相应的规则返回特定的 Version ，如果对某个对象完成了更新操作并不会直接将更新应用在其访问的 Version 对象上，而且重新创建一个新 Version 对象。
MVCC 实现 在论文中将 MVCC 的关键组件分为四个：Protocol、Version Storage、GC（Garbage Collection）和 Index，而 MVCC 所管理的逻辑对象可以是一个事务（Transactions）或者数据表的一行数据（Tuple/Record），一般都是以 tuple 为操作对象，下面都以 tuple 来介绍。tuple 的存储格式如下（不同 protocol 会有所区别） 1. Protocol MVTO（Timestamp Ordering） MVTO 为每个事务分配一个唯一的时间戳($T_{id}$)，它会中止所有试图读/更新已经被设置 write lock 的 version tuple（当 txn-id 不等于 0 或者自己的 $T_{id}$ 时表示有其他事务持有 write lock）的事务。MVTO 协议的 tuple header 如下： 对 tuple A 进行读操作： a....</p></section><footer class=entry-footer><time>February 13, 2023</time></footer><a class=entry-link href=https://baymaxhwy.github.io/2023/mvcc/></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://baymaxhwy.github.io/>hwy的小窝</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</span>
<span>&#183;</span>
<span>Theme️ <a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper</a></span></footer><script src=https://baymaxhwy.github.io/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script></body></html>